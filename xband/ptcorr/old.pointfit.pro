;+
; NAME: pointfit
;
; PURPOSE: performs az and alt dial, flop, and skew fitting for both
; dishes.  This procedure is also used by ANALYZE.
;
; EXPLANATION: 
;        This procedure reads in a list of offsets
;        generated by ERRORS and uses least squares 
;        fitting to find value for the pointing constants
;        used in CORRECT (and thus POINT2)
;
; CALLING SEQUENCE:
;        pointfit,file[,cor,/verbose,/plotit,/silent,/savename=string,logname=string]
;
; INPUTS: 
;        file - the name of the save file generated by ERRORS
;        
;
; OPTIONAL INPUT KEYWORDS:
;       /verbose - prints useful stuff
;       /plotit - plot each fit in whatever window is open,
;                 and prompt the user before continuing
;       /silent - not verbose or plotit
;       savename - the name of the file to which cor should be saved 
;       logname - the name of the fiel to which a list of corrections
;                 should be printed (human-readable text)
;
; OUTPUTS: 
;       cor - a structure which contains the pointing corrections
;
; EXAMPLES:
;       pointfit,'~/xband/ptcorr/2/errors.sav',/plotit 
;
; RESTRICTIONS: may change the value of silent
;
; PROCEDURES CALLED: ALTFIT, AZFIT
;
; REVISION HISTORY: written by Erik Shirokoff, 5/2001
;-

pro pointfit,file,cor,verbose=verbose,plotit=plotit,savename=savename,logname=logname,silent=silent

verby=keyword_Set(verbose)
shh=keyword_Set(silent)

filename=smartname('./',file,'.sav')
if verby then print,filename
restore,filename=filename,verbose=verby

if verby then help,/structure,out


;BREAK THE STRUCTURE INTO ARRAYS

exp=out.expected
delta=out.errors
moon=out.moon
reverse=out.reverse
kill=out.kill

;MAKE ARRAYS INTO WHICH TO PUT THE FITS
corr=fltarr(2,4,9) ;[a,b,c]:
                   ;a = [dial, flop or skew]
                   ;b = [alte,altw,aze,azw]
                   ;c=[0 - forward sun correction]
                   ;d=[1 - reverse sun correction]
                   ;d=[2 - combined f&r sun correction
                   ;d=[3 - forward moon correction
                   ;d=[4 - reverse moon correction
                   ;d=[5 - combined f&r moon correction
                   ;d=[6 - forward sun and moon correction
                   ;d=[7 - reverse sun and moon correction
                   ;d=[8 - combined f&r sun&moon correction

sigmar=fltarr(2,4,9) ; same scheme as above
pointsr=fltarr(2,4,9)

;plot,kill 
;trash=get_kbrd(1)
okill=kill ; the original kill indexes
;NOW LETS DO THE FITS
for nr=0,8 do begin


;TAKE OUT THE COMBINED FORWARD AND REVERSE MODES, CAUSE WE DON'T WANT
;THAT ANY MORE
badkeys=(nr eq 2) + (nr eq 5)+(nr eq 8)
if badkeys eq 0 then begin



    ;east alt
    killit=kill[*,0]
    altfit,nr,delta[*,0],exp[*,0],reverse,moon,killit,dial,flop,sigma,points,plotit=plotit,ewd=0
    kill[*,0]=killit
    corr[0,0,nr]=dial
    corr[1,0,nr]=flop
    sigmar[*,0,nr]=sigma
    pointsr[*,0,nr]=points
    print,points

    ;west alt
    killit=kill[*,0]
    altfit,nr,delta[*,1],exp[*,1],reverse,moon,killit,dial,flop,sigma,points,plotit=plotit,ewd=1
    kill[*,0]=killit
    corr[0,1,nr]=dial
    corr[1,1,nr]=flop
    sigmar[*,1,nr]=sigma
    pointsr[*,1,nr]=points
print,points
print,dial

    ;east az
    killit=kill[*,0]
    azfit,nr,delta[*,2],exp[*,0],reverse,moon,killit,dial,flop,sigma,points,plotit=plotit,ewd=0
    kill[*,0]=killit
    corr[0,2,nr]=dial
    corr[1,2,nr]=flop
    sigmar[*,2,nr]=sigma
    pointsr[*,2,nr]=points
print,dial

    ;west az  
    killit=kill[*,0]
    azfit,nr,delta[*,3],exp[*,1],reverse,moon,killit,dial,flop,sigma,points,plotit=plotit,ewd=1
    kill[*,0]=killit
    corr[0,3,nr]=dial
    corr[1,3,nr]=flop
    sigmar[*,3,nr]=sigma
    pointsr[*,3,nr]=points
print,dial

endif else begin
    corr[*,*,nr]=-1000
    sigmar[*,*,nr]=-1000
    pointsr[*,*,nr]=0
    endelse
endfor

print,'would you like to add the removes points to your permanent kill file?(y/n)'
r=get_kbrd(1)
if strmatch(r,'y',/fold_case) then begin
   out.kill=kill 
   save,filename=filename,out
   endif else begin
       kill=okill
   endelse


;Now display stuff

;make display tags
info1=strarr(2,4)
info3=strarr(9)
info2=strarr(4)

info1[0,0]='altdial'
info1[0,1]='altial'
info1[0,2]='azdial'
info1[0,3]='azdial'

info1[1,0]='flop'
info1[1,1]='flop'
info1[1,2]='skew'
info1[1,3]='skew'

info2[0]='east'
info2[2]='east'
info2[1]='west'
info2[3]='west'

info3[0]='0 - forward sun correction'
info3[1]='1 - reverse sun correction'
info3[2]='2 - combined f&r sun correction'
info3[3]='3 - forward moon correction'
info3[4]='4 - reverse moon correction'
info3[5]='5 - combined f&r moon correction'
info3[6]='6 - forward sun and moon correction'
info3[7]='7 - reverse sun and moon correction'
info3[8]='8 - combined f&r sun&moon correction'

log=strarr(8*4*2)


cor={cors:corr,$
     sigma:sigmar,$
     info1:info1,$
     info2:info2,$
     info3:info3,$
     points:pointsr}


path=smartname(' ',filename,' ',/getpath)
if keyword_set(savename) then $
  name1=smartname(path,savename,'.sav')  else $
  name1=smartname(path,'pointfit','.sav')


save,filename=name1,cor

if keyword_set(logname) then $
  name2=smartname(path,logname,'.log')  else $
  name2=smartname(path,'pointfit','.log')

openw,unit,name2,/get_lun
printf,unit,systime()
printf,unit,path
printf,unit,' '

    for c=0,8 do begin
        if verby then print,' '
        printf,unit,' '
        if verby then print,info3[c]
        printf,unit,info3[c]
        for b=0,3 do begin
            for a=0,1 do begin
                ;if verby then print,'a,b,c',nstr(a),strn(b),strn(c)
                if verby then print,info2[b]+' '+info1[a,b]+': '$
                  +strn(cor.cors[a,b,c])+$
                  ' /pm '+strn(cor.sigma[a,b,c])+$
                  '      npoints='+strn(fix(cor.points[a,b,c]))
                printf,unit,info2[b]+' '+info1[a,b]+': '$
                  +strn(cor.cors[a,b,c])+$
                  ' /pm '+strn(cor.sigma[a,b,c])+$
                  '      npoints='+strn(fix(cor.points[a,b,c]))
            endfor
        endfor
    endfor
close,unit
free_lun,unit

end












